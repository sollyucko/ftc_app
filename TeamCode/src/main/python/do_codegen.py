import json

from sys import argv
from collections import defaultdict
from itertools import product
from mypy_extensions import TypedDict
from typing import Any, Callable, Collection, Mapping, MutableMapping, Tuple, TypeVar, Union

K = TypeVar('K')
V = TypeVar('V')


def get_or_call(mapping: Mapping[K, V], key: K, default: Callable[[], V]) -> V:
    try:
        return mapping[key]
    except KeyError:
        return default()


def multiply_components(components1: Mapping[str, int], components2: Mapping[str, int]) -> Mapping[str, int]:
    result: MutableMapping[str, int] = defaultdict(int)
    for key, value in components1.items():
        result[key] += value
    for key, value in components2.items():
        result[key] += value
    return result


def compare_components(components1: Mapping[str, int], components2: Mapping[str, int]) -> bool:
    for key, value in components1.items():
        if components2[key] != value:
            return False
    for key, value in components2.items():
        if components1[key] != value:
            return False
    return True


class RawClassData(TypedDict, total=False):
    units: Mapping[str, Union[str, float]]
    components: Mapping[str, int]
    extra: str
    companion_extra: str


class RawData(TypedDict, total=False):
    units_package: str
    geometry_package: str
    prefixes: Mapping[str, float]
    classes: Mapping[str, RawClassData]


class ClassData:
    name: str
    companion_extra: str
    components: Mapping[str, int]
    extra: str
    units: Mapping[str, str]

    def __init__(self, name: str, mapping: Mapping[str, Any]):
        self.name = name
        self.companion_extra = get_or_call(mapping, 'companion_extra', lambda: '')
        self.components = defaultdict(int, get_or_call(mapping, 'components', lambda: {name: 1}))
        self.extra = get_or_call(mapping, 'extra', lambda: '')
        self.units = get_or_call(mapping, 'units', lambda: {})


def main() -> None:
    print("?!")

    input_filepath: str = argv[1]
    gen_root: str = argv[2]

    with open(input_filepath) as input_file:
        data: RawData = json.load(input_file)

    classes: Collection[ClassData] = [
        ClassData(name, class_data)
        for name, class_data
        in data['classes'].items()
    ]
    class_products: Mapping[Tuple[str, str], str] = {
        (class1.name, class2.name):
            class3.name
        for class1, class2, class3
        in product(classes, classes, classes)
        if compare_components(multiply_components(class1.components, class2.components), class3.components)
    }
    units_package = data['units_package']
    units_filepath = f'{gen_root}/{units_package.replace(".", "/")}/units.kt'
    geometry_package = data['geometry_package']
    geometry_2d_filepath = f'{gen_root}/{geometry_package.replace(".", "/")}/2d.kt'
    geometry_3d_filepath = f'{gen_root}/{geometry_package.replace(".", "/")}/3d.kt'
    with open(units_filepath, 'w') as units_file, \
            open(geometry_2d_filepath, 'w') as geometry_2d_file, \
            open(geometry_3d_filepath, 'w') as geometry_3d_file:
        units_file.write(f"""
// This file was automatically generated. Changes may be overwritten at any time.
// DO NOT EDIT THIS FILE. This file was generated from TeamCode/src/main/codegen.json by TeamCode/src/main/python/do_codegen.py

@file:Suppress("EXPERIMENTAL_FEATURE_WARNING")

package {units_package}

import {units_package}.Angle.Companion.RADIAN
import {units_package}.Angle.Companion.REVOLUTION
import {geometry_package}.TAU
import {geometry_package}.hypot
import {geometry_package}.mod
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.tan

object Prefix {'{'}
    {';'.join(f'const val {pair[0]} = {pair[1]}' for pair in data['prefixes'].items())}
{'}'}

val Double.ZERO get() = 0.0
fun atan2(y: Double, x: Double) = Angle(kotlin.math.atan2(y, x))
fun merge(a: Double, b: Double) = when {'{'}
    a.isInfinite() || b.isInfinite() -> Double.POSITIVE_INFINITY
    a.isNaN() -> b
    b.isNaN() || a == b -> a
    else -> Double.POSITIVE_INFINITY
{'}'}
fun merge(a: Double, b: Double, c: Double) = when {'{'}
    a.isInfinite() || b.isInfinite() || c.isInfinite() -> Double.POSITIVE_INFINITY
    a.isNaN() -> merge(b, c)
    b.isNaN() || a == b -> merge(a, c)
    else -> Double.POSITIVE_INFINITY
{'}'}
fun sin(angle: Angle) = sin(angle._value)
fun cos(angle: Angle) = cos(angle._value)
""")
        geometry_2d_file.write(f"""
// This file was automatically generated. Changes may be overwritten at any time.
// DO NOT EDIT THIS FILE. This file was generated from TeamCode/src/main/codegen.json by TeamCode/src/main/python/do_codegen.py

package {geometry_package}

import {units_package}.*
import {units_package}.Angle.Companion.REVOLUTION
import kotlin.math.hypot

class Direction2D {'{'}
    public constructor(angle: Angle) {'{'}
        this.angle = angle.normalized
        this.x = cos(angle)
        this.y = sin(angle)
        this.vector = DoubleVector2D(x, y, hypot(x, y), this)
    {'}'}

    public constructor(vector: DoubleVector2D) {'{'}
        this.angle = atan2(vector.y, vector.x)
        this.x = vector.x / vector.magnitude
        this.y = vector.y / vector.magnitude
        this.vector = DoubleVector2D(x, y, hypot(x, y), this)
    {'}'}

    public constructor(vector: LengthVector2D) {'{'}
        this.angle = atan2(vector.x, vector.y)
        this.x = vector.x / vector.magnitude
        this.y = vector.y / vector.magnitude
        this.vector = DoubleVector2D(x, y, hypot(x, y), this)
    {'}'}

    internal constructor(angle: Angle, x: Double, y: Double) {'{'}
        this.angle = angle
        this.x = x
        this.y = y
        this.vector = DoubleVector2D(this.x, this.y, 1.0, this)
    {'}'}

    internal constructor(angle: Angle, x: Double, y: Double, vector: DoubleVector2D) {'{'}
        this.angle = angle
        this.x = x
        this.y = y
        this.vector = vector
    {'}'}

    companion object {'{'}
        val POS_X = Direction2D(Angle.ZERO, 1.0, 0.0)
        val POS_Y = Direction2D(REVOLUTION / 4.0, 0.0, 1.0)
        val NEG_X = Direction2D(REVOLUTION / 2.0, -1.0, 0.0)
        val NEG_Y = Direction2D(REVOLUTION * 3.0 / 4.0, 0.0, -1.0)
    {'}'}

    public val angle: Angle
    public val x: Double
    public val y: Double
    public val vector: DoubleVector2D
{'}'}

/** Rotation is CCW (counter-clockwise) by convention. */
class Rotation2D public constructor(public val value: Angle)

class Point2D public constructor(public val x: Length, public val y: Length)

class DoubleVector2D {'{'}
    public constructor() {'{'}
        this.x = 0.0
        this.y = 0.0
        this.magnitude = 0.0
        this.direction = Direction2D(Angle.ZERO, 0.0, 0.0, this)
    {'}'}

    public constructor(x: Double, y: Double) {'{'}
        this.x = x
        this.y = y
        this.magnitude = hypot(y, x)
        this.direction = Direction2D(atan2(y, x), x / magnitude, y / magnitude)
    {'}'}

    public constructor(magnitude: Double, direction: Direction2D) {'{'}
        this.x = direction.x * magnitude
        this.y = direction.y * magnitude
        this.magnitude = magnitude
        this.direction = direction
    {'}'}

    internal constructor(x: Double, y: Double, magnitude: Double, direction: Direction2D) {'{'}
        this.x = x
        this.y = y
        this.magnitude = magnitude
        this.direction = direction
    {'}'}

    companion object {'{'}
        val ZERO = DoubleVector2D(0.0, 0.0, 0.0, Direction2D.POS_X)
    {'}'}

    public val x: Double
    public val y: Double
    public val magnitude: Double
    public val direction: Direction2D

    public infix fun rot(rotation: Rotation2D) = DoubleVector2D(magnitude, direction + rotation)
{'}'}
operator fun DoubleVector2D.unaryPlus() = this
operator fun DoubleVector2D.unaryMinus() = DoubleVector2D(-x, -y)
infix operator fun DoubleVector2D.plus(other: DoubleVector2D) = DoubleVector2D(x + other.x, y + other.y)
infix operator fun DoubleVector2D.minus(other: DoubleVector2D) = DoubleVector2D(x - other.x, y - other.y)
infix operator fun DoubleVector2D.times(other: Double) = DoubleVector2D(x * other, y * other, magnitude * other, direction)
infix operator fun Double.times(other: DoubleVector2D) = DoubleVector2D(this * other.x, this * other.y, this * other.magnitude, other.direction)
infix operator fun DoubleVector2D.div(other: DoubleVector2D) = merge(x / other.x, y / other.y)
infix operator fun DoubleVector2D.div(other: Double) = DoubleVector2D(x / other, y / other, magnitude / other, direction)
infix fun DoubleVector2D.dot(other: DoubleVector2D) = x * other.x + y * other.y
infix fun DoubleVector2D.cross(other: DoubleVector2D) = x * other.y - y * other.x

operator fun Rotation2D.unaryPlus() = this
operator fun Rotation2D.unaryMinus() = Rotation2D(-value)
infix operator fun Rotation2D.plus(other: Rotation2D) = Rotation2D(value + other.value)
infix operator fun Rotation2D.minus(other: Rotation2D) = Rotation2D(value - other.value)
infix operator fun Rotation2D.times(other: Double) = Rotation2D(value * other)
infix operator fun Double.times(other: Rotation2D) = Rotation2D(this * other.value)
infix operator fun Rotation2D.div(other: Rotation2D) = value / other.value
infix operator fun Rotation2D.div(other: Double) = Rotation2D(value / other)

infix operator fun Direction2D.plus(other: Rotation2D) = Direction2D(angle + other.value)
infix operator fun Rotation2D.plus(other: Direction2D) = Direction2D(value + other.angle)
infix operator fun Direction2D.minus(other: Direction2D) = Rotation2D(angle - other.angle)
infix operator fun Direction2D.minus(other: Rotation2D) = Direction2D(angle - other.value)

infix operator fun Point2D.plus(other: LengthVector2D) = Point2D(x + other.x, y + other.y)
infix operator fun LengthVector2D.plus(other: Point2D) = Point2D(x + other.x, y + other.y)
infix operator fun Point2D.minus(other: Point2D) = LengthVector2D(x - other.x, y - other.y)
infix operator fun Point2D.minus(other: LengthVector2D) = Point2D(x - other.x, y - other.y)
""")
        geometry_3d_file.write(f"""
// This file was automatically generated. Changes may be overwritten at any time.
// DO NOT EDIT THIS FILE. This file was generated from TeamCode/src/main/codegen.json by TeamCode/src/main/python/do_codegen.py

package {geometry_package}

import {units_package}.*

class Point3D public constructor(public val x: Length, public val y: Length)

class DoubleVector3D {'{'}
    public constructor() {'{'}
        this.x = 0.0
        this.y = 0.0
        this.z = 0.0
        this.magnitude = 0.0
    {'}'}

    public constructor(x: Double, y: Double, z: Double) {'{'}
        this.x = x
        this.y = y
        this.z = z
        this.magnitude = hypot(x, y, z)
    {'}'}

    internal constructor(x: Double, y: Double, z: Double, magnitude: Double) {'{'}
        this.x = x
        this.y = y
        this.z = z
        this.magnitude = magnitude
    {'}'}

    public val x: Double
    public val y: Double
    public val z: Double
    public val magnitude: Double
{'}'}
operator fun DoubleVector3D.unaryPlus() = this
operator fun DoubleVector3D.unaryMinus() = DoubleVector3D(-x, -y, -z)
infix operator fun DoubleVector3D.plus(other: DoubleVector3D) = DoubleVector3D(x + other.x, y + other.y, z + other.z)
infix operator fun DoubleVector3D.minus(other: DoubleVector3D) = DoubleVector3D(x - other.x, y - other.y, z - other.z)
infix operator fun DoubleVector3D.times(other: Double) = DoubleVector3D(x * other, y * other, z * other)
infix operator fun Double.times(other: DoubleVector3D) = DoubleVector3D(this * other.x, this * other.y, this * other.z)
infix operator fun DoubleVector3D.div(other: DoubleVector3D) = merge(x / other.x, y / other.y, z / other.z)
infix operator fun DoubleVector3D.div(other: Double) = DoubleVector3D(x / other, y / other, z / other)
infix fun DoubleVector3D.dot(other: DoubleVector3D) = x * other.x + y * other.y + z * other.z
infix fun DoubleVector3D.cross(other: DoubleVector3D) = DoubleVector3D(y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x)
""")
        for c in classes:
            units_file.write(f"""
inline class {c.name}(val _value: Double) : Comparable<{c.name}> {'{'}
    companion object {'{'}
        val ZERO = {c.name}(0.0)
        val POSITIVE_INFINITY = {c.name}(Double.POSITIVE_INFINITY)
        val NaN = {c.name}(Double.NaN)
        {';'.join(f'val {unit_name} = {f"{c.name}({unit_value})" if isinstance(unit_value, float) else unit_value}' for unit_name, unit_value in c.units.items())}
        {c.companion_extra}
    {'}'}
    
    override infix operator fun compareTo(other: {c.name}) = _value.compareTo(other._value)
    fun isInfinite() = _value.isInfinite()
    fun isFinite() = _value.isFinite()
    fun isNaN() = _value.isNaN()
    {c.extra}
{'}'}
operator fun {c.name}.unaryPlus() = this
operator fun {c.name}.unaryMinus() = {c.name}(-_value)
infix operator fun {c.name}.plus(other: {c.name}) = {c.name}(_value + other._value)
infix operator fun {c.name}.minus(other: {c.name}) = {c.name}(_value - other._value)
infix operator fun {c.name}.times(other: Double) = {c.name}(_value * other)
infix operator fun Double.times(other: {c.name}) = {c.name}(this * other._value)
infix operator fun {c.name}.div(other: {c.name}) = _value / other._value
infix operator fun {c.name}.div(other: Double) = {c.name}(_value / other)
fun hypot(x: {c.name}) = x
fun hypot(x: {c.name}, y: {c.name}) = {c.name}(hypot(x._value, y._value))
fun hypot(x: {c.name}, y: {c.name}, z: {c.name}) = {c.name}(hypot(x._value, y._value, z._value))
fun atan2(y: {c.name}, x: {c.name}) = kotlin.math.atan2(y._value, x._value) * RADIAN
fun merge(a: {c.name}, b: {c.name}) = when {'{'}
    a.isInfinite() || b.isInfinite() -> {c.name}.POSITIVE_INFINITY
    a.isNaN() -> b
    b.isNaN() || a == b -> a
    else -> {c.name}.POSITIVE_INFINITY
{'}'}
fun merge(a: {c.name}, b: {c.name}, c: {c.name}) = when {'{'}
    a.isInfinite() || b.isInfinite() || c.isInfinite() -> {c.name}.POSITIVE_INFINITY
    a.isNaN() -> merge(b, c)
    b.isNaN() || a == b -> merge(a, c)
    else -> {c.name}.POSITIVE_INFINITY
{'}'}
@JvmName("sum{c.name}s")
fun List<{c.name}>.sum() = reduce {'{'} a, b -> a + b {'}'}
""")
            geometry_2d_file.write(f"""
class {c.name}Vector2D {'{'}
    public constructor() {'{'}
        this.x = {c.name}.ZERO
        this.y = {c.name}.ZERO
        this.magnitude = {c.name}.ZERO
        this.direction = Direction2D(Angle.ZERO, 0.0, 0.0)
    {'}'}
    
    public constructor(x: {c.name}, y: {c.name}) {'{'}
        this.x = x
        this.y = y
        this.magnitude = hypot(y, x)
        this.direction = Direction2D(atan2(x, y), x / magnitude, y / magnitude)
    {'}'}
    
    public constructor(magnitude: {c.name}, direction: Direction2D) {'{'}
        this.x = direction.x * magnitude
        this.y = direction.y * magnitude
        this.magnitude = magnitude
        this.direction = direction
    {'}'}
    
    internal constructor(x: {c.name}, y: {c.name}, magnitude: {c.name}, direction: Direction2D) {'{'}
        this.x = x
        this.y = y
        this.magnitude = magnitude
        this.direction = direction
    {'}'}
    
    companion object {'{'}
        val ZERO = {c.name}Vector2D({c.name}.ZERO, {c.name}.ZERO, {c.name}.ZERO, Direction2D.POS_X)
    {'}'}
    
    public val x: {c.name}
    public val y: {c.name}
    public val magnitude: {c.name}
    public val direction: Direction2D
    
    public infix fun rot(rotation: Rotation2D) = {c.name}Vector2D(magnitude, direction + rotation)
{'}'}
operator fun {c.name}Vector2D.unaryPlus() = this
operator fun {c.name}Vector2D.unaryMinus() = {c.name}Vector2D(-x, -y)
infix operator fun {c.name}Vector2D.plus(other: {c.name}Vector2D) = {c.name}Vector2D(x + other.x, y + other.y)
infix operator fun {c.name}Vector2D.minus(other: {c.name}Vector2D) = {c.name}Vector2D(x - other.x, y - other.y)
infix operator fun {c.name}Vector2D.times(other: Double) = {c.name}Vector2D(x * other, y * other, magnitude * other, direction)
infix operator fun Double.times(other: {c.name}Vector2D) = {c.name}Vector2D(this * other.x, this * other.y, this * other.magnitude, other.direction)
infix operator fun {c.name}Vector2D.div(other: {c.name}Vector2D) = merge(x / other.x, y / other.y)
infix operator fun {c.name}Vector2D.div(other: Double) = {c.name}Vector2D(x / other, y / other, magnitude / other, direction)
infix fun DoubleVector2D.dot(other: {c.name}Vector2D) = x * other.x + y * other.y
infix fun {c.name}Vector2D.dot(other: DoubleVector2D) = x * other.x + y * other.y
infix fun DoubleVector2D.cross(other: {c.name}Vector2D) = x * other.y - y * other.x
infix fun {c.name}Vector2D.cross(other: DoubleVector2D) = x * other.y - y * other.x
""")
            geometry_3d_file.write(f"""
class {c.name}Vector3D {'{'}
    public constructor() {'{'}
        this.x = {c.name}.ZERO
        this.y = {c.name}.ZERO
        this.z = {c.name}.ZERO
        this.magnitude = {c.name}.ZERO
    {'}'}

    public constructor(x: {c.name}, y: {c.name}, z: {c.name}) {'{'}
        this.x = x
        this.y = y
        this.z = z
        this.magnitude = hypot(x, y, z)
    {'}'}

    internal constructor(x: {c.name}, y: {c.name}, z: {c.name}, magnitude: {c.name}) {'{'}
        this.x = x
        this.y = y
        this.z = z
        this.magnitude = magnitude
    {'}'}

    public val x: {c.name}
    public val y: {c.name}
    public val z: {c.name}
    public val magnitude: {c.name}
{'}'}
operator fun {c.name}Vector3D.unaryPlus() = this
operator fun {c.name}Vector3D.unaryMinus() = {c.name}Vector3D(-x, -y, -z)
infix operator fun {c.name}Vector3D.plus(other: {c.name}Vector3D) = {c.name}Vector3D(x + other.x, y + other.y, z + other.z)
infix operator fun {c.name}Vector3D.minus(other: {c.name}Vector3D) = {c.name}Vector3D(x - other.x, y - other.y, z - other.z)
infix operator fun {c.name}Vector3D.times(other: Double) = {c.name}Vector3D(x * other, y * other, z * other)
infix operator fun Double.times(other: {c.name}Vector3D) = {c.name}Vector3D(this * other.x, this * other.y, this * other.z)
infix operator fun {c.name}Vector3D.div(other: {c.name}Vector3D) = merge(x / other.x, y / other.y, z / other.z)
infix operator fun {c.name}Vector3D.div(other: Double) = {c.name}Vector3D(x / other, y / other, z / other)
infix fun DoubleVector3D.dot(other: {c.name}Vector3D) = x * other.x + y * other.y + z * other.z
infix fun {c.name}Vector3D.dot(other: DoubleVector3D) = x * other.x + y * other.y + z * other.z
infix fun DoubleVector3D.cross(other: {c.name}Vector3D) = {c.name}Vector3D(y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x)
infix fun {c.name}Vector3D.cross(other: DoubleVector3D) = {c.name}Vector3D(y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x)
""")
        for (name1, name2), name3 in class_products.items():
            # This works whether name1 and name2 are the same or not.
            units_file.write(f"""
infix operator fun {name1}.times(other: {name2}) = {name3}(_value * other._value)
infix operator fun {name3}.div(other: {name1}) = {name2}(_value / other._value)
""")
            geometry_2d_file.write(f"""
infix operator fun {name1}Vector2D.times(other: {name2}) = {name3}Vector2D(x * other, y * other)
infix operator fun {name1}.times(other: {name2}Vector2D) = {name3}Vector2D(this * other.x, this * other.y)
infix fun {name1}Vector2D.dot(other: {name2}Vector2D) = x * other.x + y * other.y
infix fun {name1}Vector2D.cross(other: {name2}Vector2D) = x * other.y - y * other.x
infix operator fun {name3}Vector2D.div(other: {name1}Vector2D) = merge(x / other.x, y / other.y)
infix operator fun {name3}Vector2D.div(other: {name1}) = {name2}Vector2D(x / other, y / other)
""")
            geometry_3d_file.write(f"""
infix fun {name1}Vector3D.dot(other: {name2}Vector3D) = x * other.x + y * other.y + z * other.z
infix fun {name1}Vector3D.cross(other: {name2}Vector3D) = {name3}Vector3D(y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x)
infix operator fun {name3}Vector3D.div(other: {name1}Vector3D) = merge(x / other.x, y / other.y, z / other.z)
infix operator fun {name3}Vector3D.div(other: {name1}) = {name2}Vector3D(x / other, y / other, z / other)
""")
        for ((name11, name21), name31), ((name12, name22), name32) in product(class_products.items(),
                                                                              class_products.items()):
            pass


if __name__ == '__main__':
    main()
